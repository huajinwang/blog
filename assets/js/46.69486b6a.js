(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{540:function(_,v,t){"use strict";t.r(v);var e=t(6),i=Object(e.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("p",[_._v("浏览器输入URL后发生的事有：")]),_._v(" "),t("ul",[t("li",[_._v("合成URL")]),_._v(" "),t("li",[_._v("DNS域名解析")]),_._v(" "),t("li",[_._v("建立TCP连接")]),_._v(" "),t("li",[_._v("发送HTTP请求，服务器处理请求，返回响应结果")]),_._v(" "),t("li",[_._v("关闭TCP连接，四次挥手")]),_._v(" "),t("li",[_._v("浏览器渲染。")])]),_._v(" "),t("h2",{attrs:{id:"dns域名解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dns域名解析"}},[_._v("#")]),_._v(" DNS域名解析")]),_._v(" "),t("p",[_._v("DNS实际上事一个地址簿，里面记录了好看易记域名（如jin.com）对应的 IP 地址。")]),_._v(" "),t("p",[_._v("DNS的域名查找，查询方式是")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("浏览器缓存中")]),_._v("查找->")]),_._v(" "),t("li",[t("strong",[_._v("本地的hosts文件")]),_._v("查找->")]),_._v(" "),t("li",[t("strong",[_._v("本地DNS解析器缓存")]),_._v("查找->")]),_._v(" "),t("li",[t("strong",[_._v("本地DNS服务器")]),_._v("查找，")])]),_._v(" "),t("p",[_._v("这个过程中任何一步找到了都会结束查找流程 。 如果本地DNS服务器无法查询到，则根据本地DNS服务器设置的转发器进行查询。")]),_._v(" "),t("h2",{attrs:{id:"建立tcp连接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#建立tcp连接"}},[_._v("#")]),_._v(" 建立TCP连接")]),_._v(" "),t("p",[_._v("首先，判断是不是https的，如果是，则HTTPS其实是HTTP + SSL / TLS 两部分组成，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。")]),_._v(" "),t("p",[_._v("进行三次握手，建立TCP连接。")]),_._v(" "),t("ol",[t("li",[_._v("第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；")]),_._v(" "),t("li",[_._v("第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；")]),_._v(" "),t("li",[_._v("第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。")])]),_._v(" "),t("p",[_._v("SSL握手过程")]),_._v(" "),t("ol",[t("li",[_._v("第一阶段 建立安全能力 包括协议版本 会话Id 密码构件 压缩方法和初始随机数")]),_._v(" "),t("li",[_._v("第二阶段 服务器发送证书 密钥交换数据和证书请求，最后发送请求-相应阶段的结束信号")]),_._v(" "),t("li",[_._v("第三阶段 如果有证书请求客户端发送此证书 之后客户端发送密钥交换数据 也可以发送证书验证消息")]),_._v(" "),t("li",[_._v("第四阶段 变更密码构件和结束握手协议")])]),_._v(" "),t("p",[_._v("完成了之后，客户端和服务器端就可以开始传送数据。更多 HTTPS 的资料可以看这里：")]),_._v(" "),t("ul",[t("li",[_._v("https://zhuanlan.zhihu.com/p/26682342")]),_._v(" "),t("li",[_._v("https://segmentfault.com/a/1190000012196642")])]),_._v(" "),t("p",[t("strong",[t("code",[_._v("备注")])])]),_._v(" "),t("p",[_._v("ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0。TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1。")]),_._v(" "),t("p",[_._v("SYN(SYNchronization)：在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。")]),_._v(" "),t("p",[_._v("FIN(finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。")]),_._v(" "),t("h2",{attrs:{id:"发送http请求-服务器处理请求-返回响应结果"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发送http请求-服务器处理请求-返回响应结果"}},[_._v("#")]),_._v(" "),t("strong",[_._v("发送HTTP请求，服务器处理请求，返回响应结果")])]),_._v(" "),t("p",[_._v("TCP连接建立后，浏览器就可以利用HTTP／HTTPS协议向服务器发送请求了。服务器接受到请求，就解析请求头，如果头部有缓存相关信息如if-none-match与if-modified-since，则验证缓存是否有效，若有效则返回状态码为304，若无效则重新返回资源，状态码为200.")]),_._v(" "),t("h2",{attrs:{id:"关闭tcp连接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关闭tcp连接"}},[_._v("#")]),_._v(" "),t("strong",[_._v("关闭TCP连接")])]),_._v(" "),t("ol",[t("li",[_._v("第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；")]),_._v(" "),t("li",[_._v('第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我"同意"你的关闭请求；')]),_._v(" "),t("li",[_._v("第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；")]),_._v(" "),t("li",[_._v("第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。")])]),_._v(" "),t("h2",{attrs:{id:"浏览器渲染"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染"}},[_._v("#")]),_._v(" "),t("strong",[_._v("浏览器渲染")])]),_._v(" "),t("ol",[t("li",[_._v("渲染进程将 HTML 内容转换为能够读懂DOM 树结构。")]),_._v(" "),t("li",[_._v("渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。")]),_._v(" "),t("li",[_._v("创建布局树，并计算元素的布局信息。")]),_._v(" "),t("li",[_._v("对布局树进行分层，并生成分层树。")]),_._v(" "),t("li",[_._v("为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转换成位图。")]),_._v(" "),t("li",[_._v("合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。")])]),_._v(" "),t("h2",{attrs:{id:"开发中做的优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#开发中做的优化"}},[_._v("#")]),_._v(" 开发中做的优化")]),_._v(" "),t("ol",[t("li",[_._v("在引入顺序上，CSS 资源先于 JavaScript 资源。样式文件应当在 head 标签中，而脚本文件在 body 结束前，这样可以防止阻塞的方式。")]),_._v(" "),t("li",[_._v("尽量减少在 JavaScript 中进行DOM操作。")]),_._v(" "),t("li",[_._v("简化并优化CSS选择器，尽量将嵌套层减少到最小。")])])])}),[],!1,null,null,null);v.default=i.exports}}]);